<!-- 
 Architecture file translated from ifar repository N04K04L01.FC15FO25.AREA1DELAY1.CMOS90NM.BPTM

 Simple architecture file consisting of clusters of 4 BLEs, each BLE contains a 4-LUT+FF pair.  Delay models from 90nm PTM.
-->
<architecture>
  <!-- 
       ODIN II specific config begins 
       Describes the types of user-specified netlist blocks (in blif, this corresponds to 
       ".model [type_of_block]") that this architecture supports.

       Note: Basic LUTs, I/Os, and flip-flops are not included here as there are 
       already special structures in blif (.names, .input, .output, and .latch) 
       that describe them.
  -->
  <models>
  </models>
  <tiles>
    <!--
        Content inside this tag contains a group of <pb_type> tags that specify the types of functional blocks and their properties.
        This is just a generall outline of what to expect, mailny meant for ODIN II. a more in depth description is found bellow in <complexblocklist>
            ex: we will be using an input/output tile
                -->
    <tile name="io"> <!--Declare tile name-->
      <sub_tile name="io" capacity="3"> <!--there are three of these at each grid location-->
        <equivalent_sites><!--set equivelencies_______________________-->
          <site pb_type="io" pin_mapping="direct"/> 
        </equivalent_sites>
        <input name="outpad" num_pins="1"/><!--Here we say there is an input, there will only be one of these per block-->
        <output name="inpad" num_pins="1"/><!--Same, notice how output relates to inpad. similar to how tx connects to rx-->
        <clock name="clock" num_pins="1"/><!--here we designate the clock pin-->
        <fc in_type="frac" in_val="1.0" out_type="frac" out_val="0.25"/><!--______________________________________-->
        <pinlocations pattern="custom"><!--Here we will declare orientations of the io pins in relation to the final CAD image-->
          <loc side="left">io.outpad io.inpad io.clock</loc><!--On the left side, each block will have an input, output, and a clock-->
          <loc side="top">io.outpad io.inpad io.clock</loc>
          <loc side="right">io.outpad io.inpad io.clock</loc>
          <loc side="bottom">io.outpad io.inpad io.clock</loc>
        </pinlocations>
      </sub_tile>
    </tile>
    <tile name="clb"><!--Now a CLB tile, again this is just basic informaation, full descriptions found in another section-->
      <sub_tile name="clb"><!--this is one occasion whe we might want a subtile. We can have just logic clb's memory clb's or others. 
                                    they are all clb and share some characteristics but cant all be named 'clb' so subtile-->
        <equivalent_sites>
          <site pb_type="clb" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="I" num_pins="10" equivalent="full"/><!-- the clb will have 10 inputs, the order of the inputs doesnt matter as the equivelence is full-->
        <output name="O" num_pins="4" equivalent="instance"/> <!--4 outputs, equivalence depends on usage-->
        <clock name="clk" num_pins="1"/>
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.25"/>
        <pinlocations pattern="spread"/><!--here we are using a pre-built pattern and saying that it will just be spread accross the entire fpga
                                                        pretty much and blank space will be filled with this-->
      </sub_tile>
    </tile>
  </tiles>
  <!--This was all for the ODIN II configurations, from this point on we more deeply describe the in physical characteristics-->

  <!--Now we add more phisical description for the other parts of VTR-->
  <layout>
    <auto_layout aspect_ratio="1.000000"><!--Here we are simply declaring that the overall board should be square. X->Y dimensions are 1:1, may also use 'fixed_layout'
                                                        if you wish to specify the exact width and height of the board 'in integers'-->
      <!--Perimeter of 'io' blocks with 'EMPTY' blocks at corners-->
      <perimeter type="io" priority="100"/><!--We want the ouside borders to be i/o pins. to assure this we use an unneccesarily large number to bully its priority-->
      <corners type="EMPTY" priority="101"/><!--Any block in the corners would mena more tracing, adn more complexity. 
                                                        A typical board does not need an extra X io pins so we do not put them in the design. 
                                                        still bully everything else and set priority above io pins. Note, just an increment of 1 is enough-->
      <!--Fill with 'clb'-->
      <fill type="clb" priority="10"/><!--Use 'Fill' to populate the entire board with a single block type. This should generally be a low priority
                                                     so that you can overwrite other block on top of it. For other blocks use items like 'row'  'col' 'single' and 'region'-->
    </auto_layout>
  </layout>
  <device>
    <sizing R_minW_nmos="4220.930176" R_minW_pmos="11207.599609"/><!--The resistance of minimum-width nmos and pmos transistor. This data is used only by the area model built into VPR.-->
    <area grid_logic_tile_area="2229.320068"/><!--Total area used by each block, this does not include routing blocks, only logic blocks-->
    <chan_width_distr><!--Alows more detailed specifications of the channel routing widths-->
      <x distr="uniform" peak="1.000000"/><!--We want a uniform, uwavering distribution (all widths the same). With a size of 1 (nm?)-->
      <y distr="uniform" peak="1.000000"/>
    </chan_width_distr>
    <switch_block type="wilton" fs="3"/><!--Self explanatory-->
    <connection_block input_switch_name="ipin_cblock"/><!--Type of switch used to connect routing tracks to logic blocks. Switchtypes specified in 'switchlist'-->
  </device>
  <switchlist><!--Self explanatory. List of different switches use to connectwires and pins-->
    <switch type="mux" name="0" R="0.000000" Cin="0.000000e+00" Cout="0.000000e+00" Tdel="6.244000e-11" mux_trans_size="1.835460" buf_size="10.498600"/>
    <!--Describes the switch. type may be 'mux' 'tristate' 'pass_gate' 'short' 'buffer' with corresponding attributes
                    name-how the switch will be called. Note above we called ipin_cblock, which is described below
                    R - Switch resistance. Cin -input capacitance Cout-Output capacitance
                    Tdel-intrinsic delay of the switch. NOT the full delay witch is described by the eq. Tdel + R*Cout, however VPR only takes Tdel into consideration
                    mux_trans_size - physical size of the internal transistors. buf_size-Only needed for isolating switch types, as these are the only ones with buffers-->
    <switch type="mux" name="ipin_cblock" R="1055.232544" Cout="0." Cin="0.000000e+00" Tdel="8.045000e-11" mux_trans_size="0.983352" buf_size="auto"/>
  </switchlist>
  <segmentlist>
    <segment freq="1.000000" length="1" type="unidir" Rmetal="0.000000" Cmetal="0.000000e+00"><!--freq - supply of ri=outing tracks. enables VPR to determine a percentage of wires that use this
            length, number of blocks a segment travels. Rmetal-resistance. Cmetal-capacitance R and C are in terms of unit length (1 block). type - directionality of the wires-->
      <mux name="0"/><!--name of the switch, from switchlists. used to drive this type of segment. only for unidirectional wires-->
      <sb type="pattern">1 1</sb><!--This represents the pattern of switchblocks in standard binary. the pattenr must be length+1. ie if length were 2: 1 0 1 would be valid-->
      <cb type="pattern">1</cb><!--Pattern of connection blocks. Pattern length is the same as length of segment-->
    </segment>
  </segmentlist>
  <complexblocklist><!-- here we will describe the io and clb blocks more in depth.-->
    <!-- Define I/O pads begin -->
    <!-- Capacity is a unique property of I/Os, it is the maximum number of I/Os that can be placed at the same (X,Y) location on the FPGA -->
    <pb_type name="io"><!--Declare that we are describing the io pins-->
      <input name="outpad" num_pins="1"/><!-- one 'out' pin per xy location-->
      <output name="inpad" num_pins="1"/>
      <clock name="clock" num_pins="1"/>
      <!-- IOs can operate as either inputs or outputs.
	     Delays below come from Ian Kuon. They are small, so they should be interpreted as
	     the delays to and from registers in the I/O (and generally I/Os are registered 
	     today and that is when you timing analyze them.
	     -->
      <mode name="inpad">
        <pb_type name="inpad" blif_model=".input" num_pb="1"><!--Now defining what the 'inpad' referenced above means. it uses a primitive blif_model. 
                                                                    and the are only 1 of its king at this hierarchy--> 
          <output name="inpad" num_pins="1"/><!--The input comes from the primitive and the output (to the board) goes to the io output-->
        </pb_type>
        <interconnect><!--Decribe the internal connections of the port-->
          <direct name="inpad" input="inpad.inpad" output="io.inpad"><!--Actually describes the connection from the primitive to the internal output-->
            <delay_constant max="9.492000e-11" in_port="inpad.inpad" out_port="io.inpad"/><!--Describes the delay and timing of the connection-->
          </direct>
        </interconnect>
      </mode>
      <mode name="outpad"><!-- essentially the same as the inpad mode above, however in reverse-->
        <pb_type name="outpad" blif_model=".output" num_pb="1">
          <input name="outpad" num_pins="1"/><!--Note how here there is an input rather than an output. outpad gets data from the board and outputs it
                                                                to the user. A comparable situation is the relationship between tx and rx. One devices rx is always paired to the others tx-->
        </pb_type>
        <interconnect>
          <direct name="outpad" input="io.outpad" output="outpad.outpad">
            <delay_constant max="2.675000e-11" in_port="io.outpad" out_port="outpad.outpad"/>
          </direct>
        </interconnect>
      </mode>
      <!-- Every input pin is driven by 15% of the tracks in a channel, every output pin is driven by 10% of the tracks in a channel -->
      <!-- IOs go on the periphery of the FPGA, for consistency, 
          make it physically equivalent on all sides so that only one definition of I/Os is needed.
          If I do not make a physically equivalent definition, then I need to define 4 different I/Os, one for each side of the FPGA
        -->
      <!-- Place I/Os on the sides of the FPGA -->
      <power method="ignore"/><!--Indicates the method of power estimation used for the given pb_type.-->
    </pb_type>
    <!-- Define I/O pads ends -->
    <!-- Define general purpose logic block (CLB) begin -->
    <pb_type name="clb">
      <input name="I" num_pins="10" equivalent="full"/><!--There are 10 input pins. equivalent=full means that the order of them does not matter-->
      <output name="O" num_pins="4" equivalent="instance"/>
      <clock name="clk" num_pins="1"/>
      <!-- Describe basic logic element. -->
      <pb_type name="fle" num_pb="4"><!--Number per block is 4. There will be 4 fle's per XY location-->
        <input name="in" num_pins="4"/><!--Four input pins per fle, connections not yet described-->
        <output name="out" num_pins="1"/>
        <clock name="clk" num_pins="1"/>
        <!-- 6-LUT mode definition begin -->
        <mode name="n1_lut4">
          <!-- Define 6-LUT mode -->
          <pb_type name="ble4" num_pb="1"><!--At this hierarchy, there is one ble4 per fle, it no longer applies to the XY coordinate-->
            <input name="in" num_pins="4"/>
            <output name="out" num_pins="1"/>
            <clock name="clk" num_pins="1"/>
            <!-- Define LUT -->
            <pb_type name="lut4" blif_model=".names" num_pb="1" class="lut"><!--There is a lut class in the VTR system to do stuff for you.
                                                                                            Only one LUT per ble, and so 1 per fle, LUTs have been made a
                                                                                            primitive as they are used so often in FPGA design-->
              <input name="in" num_pins="4" port_class="lut_in"/><!--Use the features built into the VTR system for LUTS, and simply say the number of pins-->
              <output name="out" num_pins="1" port_class="lut_out"/><!--Use the features built into the VTR system for LUTS, and simply say the number of pins-->
                            <!--Describe the timing delay. In actuality we have a matrix of values, for VTR we take the average of the N values and populate 
                                    an N size matrix with this value for each index-->
              <!-- LUT timing using delay matrix -->
              <delay_matrix type="max" in_port="lut4.in" out_port="lut4.out">
                2.253000e-10
                2.253000e-10
                2.253000e-10
                2.253000e-10
              </delay_matrix>
            </pb_type>
             <!--Each ble has a LUT and a flip flop, now we describe the flip flop-->
            <pb_type name="ff" blif_model=".latch" num_pb="1" class="flipflop"><!--again there is a primitive and class stored within the VTR 
                                                                                                system as flipflops are used often-->
              <input name="D" num_pins="1" port_class="D"/>
              <output name="Q" num_pins="1" port_class="Q"/>
              <clock name="clk" num_pins="1" port_class="clock"/>
              <T_setup value="2.160000e-10" port="ff.D" clock="clk"/><!--Here we describe the timing values for the setup of the flipflop-->
              <T_clock_to_Q max="1.426000e-10" port="ff.Q" clock="clk"/><!--Here we describe the timing from clock to Q-->
            </pb_type><!--We have now described all the parts within an fle (a ble and a flipflop), now we describe how they are connected
                                Wires are described as a one directional path with an input and an output-->
            <interconnect>
              <direct name="direct1" input="ble4.in" output="lut4[0:0].in"/>
              <direct name="direct2" input="lut4.out" output="ff.D">
                <!-- Advanced user option that tells CAD tool to find LUT+FF pairs in netlist -->
                <pack_pattern name="ble6" in_port="lut4.out" out_port="ff.D"/>
              </direct>
              <direct name="direct3" input="ble4.clk" output="ff.clk"/><!--Here we are simply stating inheritance (connecting) from ble to ff-->
              <mux name="mux1" input="ff.Q lut4.out" output="ble4.out"><!--Basic multiplexer setup, self explanatory-->
              </mux>
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="direct1" input="fle.in" output="ble4.in"/><!--Now we are navigating the hierarchy between the fle and the ble-->
            <direct name="direct2" input="ble4.out" output="fle.out[0:0]"/><!--Same as above [int:int] is for _____________________________-->
            <direct name="direct3" input="fle.clk" output="ble4.clk"/>
          </interconnect>
        </mode>
        <!-- 4-LUT mode definition end -->
      </pb_type><!--We have now completed every peice for the clb and the LUTS, we must now connect the ios of the luts to the io of the clb-->
      <interconnect>
        <!-- We use a full crossbar to get logical equivalence at inputs of CLB  -->
        <complete name="crossbar" input="clb.I fle[3:0].out" output="fle[3:0].in">
          <delay_constant max="5.735000e-11" in_port="clb.I" out_port="fle[3:0].in"/>
          <delay_constant max="5.428000e-11" in_port="fle[3:0].out" out_port="fle[3:0].in"/>
        </complete>
        <complete name="clks" input="clb.clk" output="fle[3:0].clk">
        </complete>
        <direct name="clbouts1" input="fle[3:0].out" output="clb.O"/>
      </interconnect>
      <!-- Every input pin is driven by 15% of the tracks in a channel, every output pin is driven by 25% of the tracks in a channel -->
      <!-- Place this general purpose logic block in any unspecified column -->
    </pb_type>
    <!-- Define general purpose logic block (CLB) ends -->
  </complexblocklist>
</architecture>
